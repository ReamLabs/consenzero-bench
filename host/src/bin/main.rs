use clap::Parser;
use ream_consensus::electra::beacon_state::BeaconState;
use ream_lib::{file::ssz_from_file, input::OperationInput, ssz::from_ssz_bytes};
use risc0_zkvm::{default_prover, ExecutorEnv, ProverOpts};
use tracing::{error, info};
use tree_hash::TreeHash;

mod cli;
use cli::operation::OperationName;

// // These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// // The ELF is used for proving and the ID is used for verification.
use methods::{CONSENSUS_STF_ELF, CONSENSUS_STF_ID};

/// The arguments for the command.
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    /// Argument for STFs
    #[clap(flatten)]
    fork: cli::fork::ForkArgs,

    #[clap(flatten)]
    operation: cli::operation::OperationArgs,

    #[clap(long)]
    excluded_cases: Vec<String>,
}

fn main() {
    if std::env::var("RUST_LOG").is_err() {
        std::env::set_var("RUST_LOG", "info");
    }

    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let test_case_dir = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("mainnet")
        .join("tests")
        .join("mainnet");

    if !std::path::Path::new(&test_case_dir).exists() {
        error!("Error: You must first download test data via `make download`");
        std::process::exit(1);
    }

    // Parse the command line arguments.
    let args = Args::parse();

    let fork = args.fork.fork;
    let operation_name = args.operation.operation_name;
    let excluded_cases = args.excluded_cases;

    // Load the test assets.
    // These assets are from consensus-specs repo.
    let base_dir = test_case_dir
        .join(format!("{}", fork))
        .join("operations")
        .join(format!("{}", operation_name))
        .join("pyspec_tests");

    let test_cases = ream_lib::file::get_test_cases(&base_dir);

    for test_case in test_cases {
        if excluded_cases.contains(&test_case) {
            info!("Skipping test case: {}", test_case);
            continue;
        }

        info!("{}", "-".repeat(50));
        info!("[{}] Test case: {}", operation_name, test_case);

        let case_dir = &base_dir.join(&test_case);
        let input_path = &case_dir.join(format!("{}.ssz_snappy", operation_name.to_input_name()));

        let pre_state_ssz_bytes: Vec<u8> = ssz_from_file(&case_dir.join("pre.ssz_snappy"));

        let input = match operation_name {
            OperationName::Attestation => OperationInput::Attestation(ssz_from_file(input_path)),
            OperationName::AttesterSlashing => {
                OperationInput::AttesterSlashing(ssz_from_file(input_path))
            }
            OperationName::BlockHeader => OperationInput::BeaconBlock(ssz_from_file(input_path)),
            OperationName::BLSToExecutionChange => {
                OperationInput::SignedBLSToExecutionChange(ssz_from_file(input_path))
            }
            OperationName::Deposit => OperationInput::Deposit(ssz_from_file(input_path)),
            OperationName::ExecutionPayload => {
                OperationInput::BeaconBlockBody(ssz_from_file(input_path))
            }
            OperationName::ProposerSlashing => {
                OperationInput::ProposerSlashing(ssz_from_file(input_path))
            }
            OperationName::SyncAggregate => {
                OperationInput::SyncAggregate(ssz_from_file(input_path))
            }
            OperationName::VoluntaryExit => {
                OperationInput::SignedVoluntaryExit(ssz_from_file(input_path))
            }
            OperationName::Withdrawals => {
                OperationInput::ExecutionPayload(ssz_from_file(input_path))
            }
        };

        // Setup the executor environment and inject inputs
        let env = ExecutorEnv::builder()
            // Pre-state
            .write(&pre_state_ssz_bytes.len())
            .unwrap()
            .write_slice(&pre_state_ssz_bytes)
            // Operation input
            .write(&input)
            .unwrap()
            // Build the environment
            .build()
            .unwrap();

        //
        // Prover setup & proving
        //

        let prover = default_prover();
        let opts = ProverOpts::succinct();

        let prove_info = prover
            .prove_with_opts(env, CONSENSUS_STF_ELF, &opts)
            .unwrap();

        info!("Proving complete");

        //
        // Proof verification
        //

        let receipt = prove_info.receipt;
        let new_state_root = receipt.journal.decode::<tree_hash::Hash256>().unwrap();

        info!("Seal size: {:#?}", receipt.seal_size());
        info!("Receipt: {:#?}", receipt);
        info!(
            "New state root: {:?}",
            receipt.journal.decode::<tree_hash::Hash256>().unwrap()
        );

        receipt.verify(CONSENSUS_STF_ID).unwrap();
        info!("Verfication successful. Proof is valid.");

        //
        // State root verification
        //

        let post_state_opt: Option<BeaconState> = {
            if case_dir.join("post.ssz_snappy").exists() {
                let ssz_bytes: Vec<u8> = ssz_from_file(&case_dir.join("post.ssz_snappy"));
                Some(from_ssz_bytes(&ssz_bytes).unwrap())
            } else {
                None
            }
        };

        match post_state_opt {
            Some(post_state) => {
                assert_eq!(new_state_root, post_state.tree_hash_root());
                info!("Execution is correct! State mutated and the roots match.");
            }
            None => {
                let pre_state: BeaconState = from_ssz_bytes(&pre_state_ssz_bytes).unwrap();
                assert_eq!(new_state_root, pre_state.tree_hash_root());
                info!("Execution is correct! State should not be mutated and the roots match.");
            }
        }

        info!("----- Cycle Tracker End -----");
    }
}
